<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>artofproof</title>

    <!-- Favicons -->
    <link rel="icon" href="favicon.ico" sizes="any">
    <link rel="icon" type="image/png" sizes="192x192" href="android-chrome-192x192.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">

    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>

    <style>
      body {
        margin: 0;
        background: black;
        font-family: sans-serif;
        touch-action: none; /* prevents scrolling while interacting with the joystick */
      }
      #cornerLogo {
        position: fixed;
        top: 10px;
        left: 10px;
        width: 60px;
        height: auto;
        z-index: 1000;
      }

      /* Movement controls (left) */
      #mobileControls {
        position: fixed;
        bottom: 20px;
        left: 20px;
        display: none; /* shown on touch devices */
        flex-direction: column;
        align-items: center;
        gap: 7px;
        z-index: 10010;
        -webkit-tap-highlight-color: transparent;
      }
      #mobileControls .btn-row { display:flex; gap:7px; }
      .move-btn {
        width: 56px;
        height: 56px;
        font-size: 22px;
        border-radius: 10px;
        border: none;
        background: rgba(255,255,255,0.85);
        box-shadow: 0 2px 6px rgba(0,0,0,0.4);
        touch-action: none;
      }

      /* Look joystick (right) */
      #lookJoystick {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 120px;
        height: 120px;
        border-radius: 50%;
        background: rgba(255,255,255,0.12);
        display: none;
        touch-action: none;
        z-index: 10010;
      }
      #joystickHandle {
        position: absolute;
        width: 44px;
        height: 44px;
        border-radius: 50%;
        background: rgba(255,255,255,0.92);
        top: 38px;
        left: 38px;
        transform: translate(0,0);
        transition: left 0.2s cubic-bezier(.22,.9,.22,1), top 0.2s cubic-bezier(.22,.9,.22,1);
        touch-action: none;
      }

      /* small tweak so A-Frame canvas doesn't steal pointer when interacting UI */
      a-scene { touch-action: none; }
    </style>
  </head>
  <body>
    <!-- Top-left logo linked to whitepaper -->
    <a href="https://raw.githubusercontent.com/artofproof/artofproof.github.io/refs/heads/main/whitepaper.md" target="_blank">
      <img id="cornerLogo" src="invert.png" alt="Logo">
    </a>

    <!-- Mobile movement controls -->
    <div id="mobileControls" aria-hidden="true">
      <button class="move-btn" data-dx="0" data-dz="-1" aria-label="Forward">⬆️</button>
      <div class="btn-row">
        <button class="move-btn" data-dx="-1" data-dz="0" aria-label="Left">⬅️</button>
        <button class="move-btn" data-dx="1" data-dz="0" aria-label="Right">➡️</button>
      </div>
      <button class="move-btn" data-dx="0" data-dz="1" aria-label="Back">⬇️</button>
    </div>

    <!-- Look joystick -->
    <div id="lookJoystick" aria-hidden="true">
      <div id="joystickHandle"></div>
    </div>

    <a-scene loading-screen="enabled: false"
             cursor="rayOrigin: mouse; fuse: false"
             raycaster="objects: .raycastable">

      <a-assets>
        <!-- Artworks -->
        <img id="art0" crossorigin="anonymous" src="https://raw.githubusercontent.com/artofproof/artofproof.github.io/main/art/images/114b7eb2-aa73-4012-a384-dfc5cb8bd0a6.png">
        <img id="art1" crossorigin="anonymous" src="https://raw.githubusercontent.com/artofproof/artofproof.github.io/main/art/images/205b28f0-a623-48e8-996a-04fd19c9df6a.png">
        <img id="art2" crossorigin="anonymous" src="https://raw.githubusercontent.com/artofproof/artofproof.github.io/main/art/images/4cd72a9c-ab47-460e-aa98-9dda68d7bfb2.png">
        <img id="art3" crossorigin="anonymous" src="https://raw.githubusercontent.com/artofproof/artofproof.github.io/main/art/images/8e48651d-fd26-4be3-9cec-7dec14b47bfd.png">
        <img id="art4" crossorigin="anonymous" src="https://raw.githubusercontent.com/artofproof/artofproof.github.io/main/art/images/e37460ef-dbb5-43a2-b844-d74ebed1c4bf.png">
        <img id="art5" crossorigin="anonymous" src="https://raw.githubusercontent.com/artofproof/artofproof.github.io/main/art/images/npub1q39st7du4ww4j8tr389nlw0snrwg5ctwvcdsdmhqy3prcesrwjvq6vnzug.png">

        <!-- Textures -->
        <img id="grassTexture" src="https://cdn.pixabay.com/photo/2015/03/26/09/54/grass-690300_1280.jpg">
        <img id="skyTexture" src="https://cdn.pixabay.com/photo/2016/03/09/09/30/sky-1245953_1280.jpg">
        <img id="logo" src="artofproof.png">
      </a-assets>

      <!-- Sky -->
      <a-sky src="#skyTexture" rotation="0 -90 0"></a-sky>

      <!-- Grass Floor (raycastable so users can tap it) -->
      <a-plane id="ground" class="raycastable" rotation="-90 0 0" width="50" height="50"
               src="#grassTexture" repeat="25 25"></a-plane>

      <!-- Gallery Row -->
      <a-entity id="gallery" position="0 1.6 -3">
        <a-entity id="art0-entity" position="-3 0 0" class="raycastable"
                  geometry="primitive: plane; width: 0.86; height: 1.16"
                  material="src: #art0; side: double"
                  onclick="showInfo('art0')"></a-entity>
        <a-entity id="art1-entity" position="-1.8 0 0" class="raycastable"
                  geometry="primitive: plane; width: 0.86; height: 1.16"
                  material="src: #art1; side: double"
                  onclick="showInfo('art1')"></a-entity>
        <a-entity id="art2-entity" position="-0.6 0 0" class="raycastable"
                  geometry="primitive: plane; width: 0.86; height: 1.16"
                  material="src: #art2; side: double"
                  onclick="showInfo('art2')"></a-entity>
        <a-entity id="art3-entity" position="0.6 0 0" class="raycastable"
                  geometry="primitive: plane; width: 0.86; height: 1.16"
                  material="src: #art3; side: double"
                  onclick="showInfo('art3')"></a-entity>
        <a-entity id="art4-entity" position="1.8 0 0" class="raycastable"
                  geometry="primitive: plane; width: 0.86; height: 1.16"
                  material="src: #art4; side: double"
                  onclick="showInfo('art4')"></a-entity>
        <a-entity id="art5-entity" position="3 0 0" class="raycastable"
                  geometry="primitive: plane; width: 0.86; height: 1.16"
                  material="src: #art5; side: double"
                  onclick="showInfo('art5')"></a-entity>
      </a-entity>

      <!-- Info Panel -->
      <a-entity id="infoPanel" visible="false">
        <!-- Enlarged Image -->
        <a-plane id="info-img" position="-3 10 -10" width="5" height="6"
                 material="src: #art0; side: double"></a-plane>

        <!-- Description Text to the RIGHT of the image -->
        <a-text id="info-text" value="" position="3 12 -10" align="left"
                width="12" color="white" wrap-count="60"></a-text>

        <!-- Clickable Link (npub) -->
        <a-entity id="info-link-entity" position="3 10 -10" class="raycastable"
                  geometry="primitive: plane; height: 0.4; width: 9"
                  material="transparent: true; opacity: 0">
          <a-text id="info-link" value="" align="left"
                  width="9" color="#a020f0"
                  animation="property: color; dir: alternate; dur: 800; loop: true; to: #ff00ff">
          </a-text>
        </a-entity>
      </a-entity>

      <!-- Camera Rig -->
      <a-entity id="cameraRig" position="0 1.6 0">
        <a-entity id="camera" camera wasd-controls
                  look-controls="touchEnabled: true; magicWindowTrackingEnabled: true;">
        </a-entity>
      </a-entity>

    </a-scene>

    <!-- === SCRIPT: waits for scene loaded, restores descriptions, and initialises mobile controls === -->
    <script>
      // Wait for A-Frame scene to be ready
      const scene = document.querySelector('a-scene');
      scene.addEventListener('loaded', init);

      function init() {
        // Elements
        const infoPanel = document.querySelector("#infoPanel");
        const infoText = document.querySelector("#info-text");
        const infoLink = document.querySelector("#info-link");
        const infoLinkEntity = document.querySelector("#info-link-entity");
        const infoImg = document.querySelector("#info-img");
        const cameraRig = document.querySelector("#cameraRig");
        const camera = document.querySelector("#camera");
        const ground = document.querySelector("#ground");

        // Descriptions (restored)
        const descriptions = {
          art0: {
            text: "The Protocol Punisher - Just as Frank Castle wages an unyielding war against crime and corruption, Bitcoin’s protocol enforces the incorruptible rules of a new financial order. There are no plea bargains, no backroom deals, no central authority to bend its will — only the impartial law of mathematics. The Punisher’s relentless pursuit of justice mirrors the Bitcoin whitepaper’s vision: a system where fraud is exposed, trust is unnecessary, and every transaction is judged without prejudice.",
            link: "https://nosta.me/npub14u6x8fd4kfh3ygzrnh5ny4qyeeggswr55v0z93hdme8qttvm2t9qwk9jme",
            npub: "npub14u6x8fd4kfh3ygzrnh5ny4qyeeggswr55v0z93hdme8qttvm2t9qwk9jme"
          },
          art1: {
            text: "Cipher Punk Exodus - In Cipher Punk Exodus, the chaotic energy of AKIRA’s Neo-Tokyo collides with the radical vision of Bitcoin’s whitepaper. Just as Kaneda and his crew fought against corrupt systems of power, the cypherpunks engineered a rebellion in code—an exodus from centralized control into a world governed by mathematics and peer-to-peer consensus. The artwork captures that raw transition, where neon-soaked streets echo with the hum of defiance, and every block mined is a strike against oppression.",
            link: "https://nosta.me/npub1vjck0yzrhzn4p04a9354nz3zsnrf0stmuu0a2nknrwjevmun2d2s6cmral",
            npub: "npub1vjck0yzrhzn4p04a9354nz3zsnrf0stmuu0a2nknrwjevmun2d2s6cmral"
          },
          art2: {
            text: "Code of Law - channels the spirit of Judge Dredd as the embodiment of Bitcoin’s unbreakable rules. In the Bitcoin whitepaper, consensus acts as the supreme authority — a protocol that cannot be bribed, corrupted, or persuaded. Like Dredd himself, the network enforces its law with precision and finality, ensuring that no transaction outside the rules can ever stand. This artwork captures that stark truth: in Bitcoin, justice is not human but mathematical, not arbitrary but absolute. The code is the law, and the law is incorruptible.",
            link: "https://nosta.me/npub1ppfv7rd6gq38jp6n3elgl6yydmtydp2zcjv32cgp9zyvcttpz59q7v7xrx",
            npub: "npub1ppfv7rd6gq38jp6n3elgl6yydmtydp2zcjv32cgp9zyvcttpz59q7v7xrx"
          },
          art3: {
            text: "Cryptographic Cleaner - The Cryptographic Cleaner embodies the spirit of Bitcoin’s whitepaper, a solitary figure who eliminates the need for trust, enforcing peer to peer truth with quiet precision. He operates in the shadows, guided by discipline and code, protecting the integrity of a system built to outlast its enemies.",
            link: "https://nosta.me/npub16frw5ph96ksktwjr73s8gy85aueswl3ts4uffdjrqq283wnltqqquet8sp",
            npub: "npub16frw5ph96ksktwjr73s8gy85aueswl3ts4uffdjrqq283wnltqqquet8sp"
          },
          art4: {
            text: "Protocol Enforcer - A composed figure stares ahead, Bitcoin reflected in his eyes, representing the protocol’s unwavering vigilance. The image captures the strength and resilience of the network, where cryptography and consensus work together to secure an immutable ledger, standing guard over the flow of digital value.",
            link: "https://nosta.me/npub16pg9ahu5el742q59ntnr0rwgwcffem4awjl2gxsguanvea0hk2ssrzjjsk",
            npub: "npub16pg9ahu5el742q59ntnr0rwgwcffem4awjl2gxsguanvea0hk2ssrzjjsk"
          },
          art5: {
            text: "Orphan from Hell - Orphan from Hell is a fierce, symbolic portrayal of rebellion and rejection, drawing inspiration from the concept of 'orphan blocks' in the Bitcoin whitepaper. The image features a demonic figure with glowing Bitcoin eyes, a broken horn, and a massive weapon, embodying the spirit of the outcast, rejected by consensus but burning with purpose. Raw and intense, this antihero channels the energy of those who fight from the fringes, wielding conviction like a weapon in a world that tried to leave them behind.",
            link: "https://nosta.me/npub1q39st7du4ww4j8tr389nlw0snrwg5ctwvcdsdmhqy3prcesrwjvq6vnzug",
            npub: "npub1q39st7du4ww4j8tr389nlw0snrwg5ctwvcdsdmhqy3prcesrwjvq6vnzug"
          }
        };

        // show/hide info
        window.showInfo = function(id){
          infoImg.setAttribute("material", "src: #" + id + "; side: double");
          if(descriptions[id]){
            infoText.setAttribute("value", descriptions[id].text);
            infoLink.setAttribute("value", descriptions[id].npub);
            infoLinkEntity.onclick = () => { if (descriptions[id].link) window.open(descriptions[id].link, "_blank"); };
          } else {
            infoText.setAttribute("value", ""); infoLink.setAttribute("value", ""); infoLinkEntity.onclick = null;
          }
          infoPanel.setAttribute("visible","true");
        };
        window.hideInfo = function(){ infoPanel.setAttribute("visible","false"); };
        window.addEventListener('keydown', (e) => { if(e.key === "Escape"){ hideInfo(); } });

        // tap-to-move on ground
        ground.addEventListener("click", (e) => {
          const intersect = e.detail.intersection;
          if (intersect) {
            const target = intersect.point;
            moveCameraTo(target);
          }
        });

        function moveCameraTo(target) {
          const start = cameraRig.object3D.position.clone();
          const end = new THREE.Vector3(target.x, start.y, target.z);
          let progress = 0;
          function animate() {
            progress += 0.02;
            if (progress >= 1) {
              cameraRig.object3D.position.copy(end);
              return;
            }
            cameraRig.object3D.position.lerpVectors(start, end, progress);
            requestAnimationFrame(animate);
          }
          animate();
        }

        // ---------- MOBILE UI SETUP ----------
        const isTouch = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
        if (isTouch) {
          document.getElementById('mobileControls').style.display = 'flex';
          document.getElementById('lookJoystick').style.display = 'block';

          // disable A-Frame's touch look-controls so our joystick controls are authoritative
          camera.setAttribute('look-controls', 'enabled: false');
        }

        // Movement: press & hold
        (function setupMovementButtons(){
          const buttons = document.querySelectorAll('.move-btn');
          const stepPerTick = 0.12; // smaller steps per interval for smoothness
          const tickMs = 40; // movement tick interval
          buttons.forEach(btn => {
            let intervalId = null;
            const dx = parseFloat(btn.getAttribute('data-dx')) || 0;
            const dz = parseFloat(btn.getAttribute('data-dz')) || 0;

            function doMove() {
              // safety: ensure cameraRig.object3D is available
              if (!cameraRig.object3D) return;
              cameraRig.object3D.position.x += dx * stepPerTick;
              cameraRig.object3D.position.z += dz * stepPerTick;
            }

            const start = (e) => {
              e.preventDefault();
              doMove(); // immediate
              if (intervalId) clearInterval(intervalId);
              intervalId = setInterval(doMove, tickMs);
            };
            const stop = (e) => {
              if (e) e.preventDefault();
              if (intervalId) { clearInterval(intervalId); intervalId = null; }
            };

            // touch
            btn.addEventListener('touchstart', start, { passive: false });
            btn.addEventListener('touchend', stop);
            // mouse fallback
            btn.addEventListener('mousedown', start);
            window.addEventListener('mouseup', stop);
            btn.addEventListener('mouseleave', stop);
          });
        })();

        // ---------- LOOK JOYSTICK with easing/momentum ----------
        (function setupJoystick() {
          const joystick = document.getElementById('lookJoystick');
          const handle = document.getElementById('joystickHandle');
          const maxRadius = 40; // px
          let dragging = false;
          let vx = 0, vy = 0; // rotation velocities
          let lastTime = performance.now();

          // Animation loop: applies rotation every frame using vx/vy and decays them
          function rafLoop(time) {
            const dt = (time - lastTime) / 1000;
            lastTime = time;
            if (cameraRig && cameraRig.object3D && (Math.abs(vx) > 0 || Math.abs(vy) > 0)) {
              // yaw on rig, pitch on camera (clamped)
              cameraRig.object3D.rotation.y -= vx * dt * 6.0; // scale factor controls sensitivity
              const newPitch = camera.object3D.rotation.x - vy * dt * 6.0;
              camera.object3D.rotation.x = THREE.MathUtils.clamp(newPitch, -1.4, 1.4);

              // decay velocities if not dragging
              if (!dragging) {
                vx *= 0.88;
                vy *= 0.88;
                if (Math.abs(vx) < 1e-4) vx = 0;
                if (Math.abs(vy) < 1e-4) vy = 0;
              }
            }
            requestAnimationFrame(rafLoop);
          }
          requestAnimationFrame(rafLoop);

          function joystickCenter() {
            const r = joystick.getBoundingClientRect();
            return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
          }

          function setHandlePosition(px, py) {
            // convert center-based px/py into left/top relative to container (handle default 40px offset)
            handle.style.left = (40 + px) + 'px';
            handle.style.top = (40 + py) + 'px';
          }

          function resetHandleSmooth() {
            // smooth return using CSS transition already set
            handle.style.left = '38px';
            handle.style.top = '38px';
            // remove transition after it finishes so immediate moves are not smoothed incorrectly
            setTimeout(()=> { handle.style.transition = 'left 0.12s cubic-bezier(.22,.9,.22,1), top 0.12s cubic-bezier(.22,.9,.22,1)'; }, 220);
          }

          joystick.addEventListener('touchstart', function (e) {
            e.preventDefault();
            dragging = true;
            handle.style.transition = ''; // immediate handle move while dragging
            const t = e.touches[0];
            const c = joystickCenter();
            const dx = t.clientX - c.x;
            const dy = t.clientY - c.y;
            const dist = Math.min(Math.sqrt(dx*dx + dy*dy), maxRadius);
            const angle = Math.atan2(dy, dx);
            const px = Math.cos(angle) * dist;
            const py = Math.sin(angle) * dist;
            setHandlePosition(px, py);
            // set velocities scaled to radius
            vx = (dist / maxRadius) * Math.cos(angle) * 2.2;
            vy = (dist / maxRadius) * Math.sin(angle) * 2.2;
          }, { passive: false });

          joystick.addEventListener('touchmove', function (e) {
            e.preventDefault();
            if (!dragging) return;
            const t = e.touches[0];
            const c = joystickCenter();
            const dx = t.clientX - c.x;
            const dy = t.clientY - c.y;
            const dist = Math.min(Math.sqrt(dx*dx + dy*dy), maxRadius);
            const angle = Math.atan2(dy, dx);
            const px = Math.cos(angle) * dist;
            const py = Math.sin(angle) * dist;
            setHandlePosition(px, py);
            // update velocities (instant)
            vx = (dist / maxRadius) * Math.cos(angle) * 2.2;
            vy = (dist / maxRadius) * Math.sin(angle) * 2.2;
          }, { passive: false });

          joystick.addEventListener('touchend', function (e) {
            e.preventDefault();
            dragging = false;
            // smoothly return handle to center and let momentum decay in RAF loop
            resetHandleSmooth();
          });
        })();

      } // end init
    </script>
  </body>
</html>
